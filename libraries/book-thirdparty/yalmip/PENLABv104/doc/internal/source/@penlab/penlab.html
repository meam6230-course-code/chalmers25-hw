<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of penlab</title>
  <meta name="keywords" content="penlab">
  <meta name="description" content="PenLab (Pennon Laboratory for Matlab, previously PennonM)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">source</a> &gt; <a href="index.html">@penlab</a> &gt; penlab.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for source/@penlab&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>penlab
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>PenLab (Pennon Laboratory for Matlab, previously PennonM)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> PenLab (Pennon Laboratory for Matlab, previously PennonM)
 a NLP-SDP optimization solver</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="Y2vec.html" class="code" title="function vec = Y2vec(obj, Y, Ydefault)">Y2vec</a>	Copy matrix data (with respect to the given pattern) to xall,</li><li><a href="clearstats.html" class="code" title="function [] = clearstats(obj)">clearstats</a>	Zero all statistics</li><li><a href="disp.html" class="code" title="function disp(obj)">disp</a>	overloading default disp()</li><li><a href="eqconstr_min.html" class="code" title="function [nFlag,rResults]=eqconstr_min(obj)">eqconstr_min</a>	equality constrained minimization</li><li><a href="eval_alddx.html" class="code" title="function [status] = eval_alddx(obj)">eval_alddx</a>	As eval_alx(), evaluate hessian of the Augmented Lagrangian and Jacobian</li><li><a href="eval_aldx.html" class="code" title="function [status] = eval_aldx(obj)">eval_aldx</a>	As eval_alx(), evaluate gradient of the Augmented Lagrangian and Jacobian</li><li><a href="eval_alx.html" class="code" title="function [status] = eval_alx(obj)">eval_alx</a>	Evaluate Augmented Lagrangian at the current 'xall' point with the current</li><li><a href="feas_ay.html" class="code" title="function [mfeas] = feas_ay(obj)">feas_ay</a>	Compute feasibility of the matrix constraints (A) and matrix variables (Y)</li><li><a href="init.html" class="code" title="function [] = init(obj, forceupdate)">init</a>	Initialize lagrangian multipliers, penalty parameters etc.</li><li><a href="logfile.html" class="code" title="function [] = logfile(obj,task)">logfile</a>	open/close log file based on option settings (in obj.allopts)</li><li><a href="ls_pennon.html" class="code" title="function [rRelStep, nFlag]=ls_pennon(obj, dir)">ls_pennon</a>	rewritten line_search() @ line_search_els.c @ Pennlp v.2.3 & Pennon v.0.9</li><li><a href="lseq_pen.html" class="code" title="function [rRelStep, nFlag]=lseq_pen(obj, dir, udir, miter)">lseq_pen</a>	dir/udir ... new directions for x/equality constraints multipliers</li><li><a href="penlab.html" class="code" title="">penlab</a>	PenLab (Pennon Laboratory for Matlab, previously PennonM)</li><li><a href="phi2.html" class="code" title="function [ret] = phi2(obj,t)">phi2</a>	Penalty function for augmented Lagrangian function.</li><li><a href="phi2_D.html" class="code" title="function [ret] = phi2_D(obj,t)">phi2_D</a>	Derivative od penalty function for augmented Lagrangian function.</li><li><a href="phi2_D2.html" class="code" title="function [ret] = phi2_D2(obj,t)">phi2_D2</a>	Second derivative of penalty function for augmented Lagrangian function.</li><li><a href="phibar.html" class="code" title="function [ret] = phibar(obj,t)">phibar</a>	log-penalty barrier function, t can be a scalar/vector/...</li><li><a href="phibar_D.html" class="code" title="function [ret] = phibar_D(obj,t)">phibar_D</a>	log-penalty barrier function, t can be a scalar/vector/...</li><li><a href="phibar_D2.html" class="code" title="function [ret] = phibar_D2(obj,t)">phibar_D2</a>	log-penalty barrier function, t can be a scalar/vector/...</li><li><a href="print.html" class="code" title="function [errmsg] = print(obj, minlev, maxlev, msg, varargin)">print</a>	Publisher (printing manager) for PenLab</li><li><a href="print_opts.html" class="code" title="function [errmsg] = print_opts(obj, minlev, maxlev)">print_opts</a>	print all options from the object via obj.print() and add a flag if it is</li><li><a href="setpentype.html" class="code" title="function []=setpentype(obj,lbxbar,ubxbar,lbYbar,ubYbar)">setpentype</a>	Set index sets assigning constraint numbers to the type of constraint</li><li><a href="solve_chol.html" class="code" title="function [dir,nFlag]=solve_chol(obj,matrix,rhs)">solve_chol</a>	(Modified) Newton method via Cholesky factorization (with inertia control)</li><li><a href="solvekkt_ldl.html" class="code" title="function [x_dir,ueq_dir,nFlag,pert]=solvekkt_ldl(obj,H,A,rhs1,rhs2)">solvekkt_ldl</a>	A direct solver based on LDL() function in Matlab (version 7.6, R2008a++)</li><li><a href="unconstr_min.html" class="code" title="function [nFlag,rResults]=unconstr_min(obj)">unconstr_min</a>	unconstrained minimization</li><li><a href="vec2Y.html" class="code" title="function  Y=vec2Y(obj, vec)">vec2Y</a>	Map 'vectorized' matrix decision variables back to cell array of matrices Y</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="penlab.html" class="code" title="">penlab</a>	PenLab (Pennon Laboratory for Matlab, previously PennonM)</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function obj = penlab(penm)</a></li><li><a href="#_sub2" class="code">function delete(obj)</a></li><li><a href="#_sub3" class="code">function set.opts(obj, newopts)</a></li><li><a href="#_sub4" class="code">function set.xall(obj, xall)</a></li><li><a href="#_sub5" class="code">function x=get.x(obj)</a></li><li><a href="#_sub6" class="code">function Y=get.Y(obj)</a></li><li><a href="#_sub7" class="code">function set.xinit(obj,x)</a></li><li><a href="#_sub8" class="code">function set.Yinit(obj,Y)</a></li><li><a href="#_sub9" class="code">function dname = default_probname()</a></li><li><a href="#_sub10" class="code">function dopts = default_opts()</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% PenLab (Pennon Laboratory for Matlab, previously PennonM)</span>
0002 <span class="comment">% a NLP-SDP optimization solver</span>
0003 classdef <a href="penlab.html" class="code" title="">penlab</a> &lt; handle
0004   
0005   properties   <span class="comment">% fully public</span>
0006     <span class="comment">% Problem (object) name with optional comments</span>
0007     probname = <span class="string">'No problem loaded'</span>; 
0008     comment = <span class="string">''</span>;
0009 
0010     <span class="comment">% user data structure to be passed to callbacks</span>
0011     userdata = [];
0012 
0013     <span class="comment">% (accepted) user's option settings</span>
0014     opts = struct();
0015 
0016     <span class="comment">% starting point given by user</span>
0017     xinit = [];
0018     Yinit = [];
0019 
0020   <span class="keyword">end</span>
0021 
0022   properties (SetAccess = private)
0023     <span class="comment">% phase of the object, 0 ~ EMPTY, 1 ~ INIT, 2 ~ SOLVING, 3 ~ FINISHED</span>
0024     phase = 0;
0025 
0026     <span class="comment">% number of variables (in a vector)</span>
0027     Nx = 0;
0028     <span class="comment">% number of matrix variables</span>
0029     NY = 0;
0030     <span class="comment">% number of variables in all matrix variables together</span>
0031     NYnnz = 0;
0032     <span class="comment">% how are variables mapped into matricies Y, just to inform user</span>
0033     Ymap = [];
0034 
0035     <span class="comment">% number of nonlinear constraint functions</span>
0036     NgNLN = 0;
0037     <span class="comment">% number of linear constraint functions</span>
0038     NgLIN = 0;
0039     <span class="comment">% number of nonlinear matrix constraint functions</span>
0040     NANLN = 0;
0041     <span class="comment">% number of linear matrix constraint functions</span>
0042     NALIN = 0;
0043 
0044     <span class="comment">% current point (or result), only updated via get.x(), get.Y() as</span>
0045     <span class="comment">% a projection of xall</span>
0046     x = [];
0047     Y = [];
0048 
0049     <span class="comment">%% Statistics</span>
0050     <span class="comment">% no of objfun calls ...</span>
0051     <span class="comment">% no of outer iterations (completed)</span>
0052     <span class="comment">% no of inner iterations (completed)</span>
0053     stats_ncall_alx = 0;
0054     stats_time_alx = 0;
0055     stats_ncall_aldx = 0;
0056     stats_time_aldx = 0;
0057     stats_ncall_alddx = 0;
0058     stats_time_alddx = 0;
0059     stats_time_fact_last = 0;
0060     stats_time_fact = 0;
0061     stats_time_miter_last = 0;
0062     stats_time_miters = 0;
0063     stats_time_total = 0;
0064     miter = 0;
0065     miter_last = 0;
0066     initer = 0;
0067     initer_last = 0;
0068     lsiter = 0;
0069     lsiter_last = 0;
0070     <span class="comment">% add major iteration counter, inner iteration counter, LS steps</span>
0071     <span class="comment">% time factor, total</span>
0072 
0073     <span class="comment">% status/meassures while solving and when solver finished</span>
0074     solveflag = [];
0075     rFeas = [];
0076     rCompl = [];
0077     rNormG = [];
0078 
0079     <span class="comment">% or set it up as 'empty routine'?</span>
0080     <span class="comment">% objfun = @(x,Y,userdata) deal([],userdata);</span>
0081     objfun = [];
0082     objgrad = [];
0083     objhess = [];
0084     confun = [];
0085     congrad = [];
0086     conhess = [];
0087     lagrhess = [];
0088     mconfun = [];
0089     mcongrad = [];
0090     mconhess = [];
0091     mconlagrhess = [];
0092 
0093     <span class="comment">% all option settings (default + user's)</span>
0094     <span class="comment">% allopts is linked with opts via set.opts() and shouldn't be changed</span>
0095     <span class="comment">% directly</span>
0096     allopts = penlab.defopts(1);
0097 
0098     <span class="comment">%%%%%%%%%%%%%%%%% MAKE ME PRIVATE LATER %%%%%%%%%%%%%%%%%%%%%%</span>
0099     <span class="comment">% real number of constraints</span>
0100 
0101     <span class="comment">% number of box constraints on X</span>
0102     Nxbox = 0;
0103     <span class="comment">% mapping: Nxbox (internal numebring) -&gt; Nx bounds</span>
0104     xboxmap = [];
0105     xboxmlt = [];
0106     xboxshift = [];
0107     <span class="comment">% number of matrix box constraints (no of inequal on Y matrix variables)</span>
0108     NYbox = 0;
0109     <span class="comment">% vectorized variable (xall(Nx+1:Nx+NYnnz) into Y map</span>
0110     vec2Ymap = [];
0111     <span class="comment">% mapping: no &quot;box&quot; matrix inequality constraint -&gt; k  of appropriate Y{k}</span>
0112     Yboxmap = [];
0113     Yboxmlt = [];
0114     Yboxshift = [];
0115     <span class="comment">% box constraints on the elements of the matrix variables &lt;== among xbox*</span>
0116     <span class="comment">%NYxbox = 0;</span>
0117     <span class="comment">%Yxboxmap = [];</span>
0118     <span class="comment">%Yxboxmlt = [];</span>
0119     <span class="comment">%Yxboxshift = [];</span>
0120     <span class="comment">% equality on the elements...? &lt;== at the moment 2 inequalities</span>
0121     <span class="comment">%NYxboxeq = 0;</span>
0122     <span class="comment">%Yxboxmapeq = [];</span>
0123     <span class="comment">%Yxboxshifteq = [];</span>
0124 
0125     <span class="comment">% function inequalities, nonlin &amp; lin merged (but in this order)</span>
0126     <span class="comment">%NineqNLN = 0;</span>
0127     <span class="comment">%NineqLIN = 0;</span>
0128     Nineq = 0;
0129     ineqmap = [];
0130     ineqmlt = [];
0131     ineqshift = [];
0132     <span class="comment">% function equalities, nonlin &amp; lin</span>
0133     Neq = 0;
0134     eqmap = [];
0135     eqshift = [];
0136     <span class="comment">% matrix inequalitites, nonlin &amp; lin merged (kept in order)</span>
0137     NA = 0;
0138     Amap = [];
0139     Amlt = [];
0140     Ashift = [];
0141     <span class="comment">% list of dependent variables on A(k) k=1..NANLN+NALIN, i.e., the original</span>
0142     <span class="comment">% numbering of matrix constraints</span>
0143     Adep=[];
0144 
0145     <span class="comment">% type of the penalty used for function and matrix inequalitites</span>
0146     xboxtype = [];
0147     ineqtype = [];
0148     Yboxtype = [];
0149     Atype = [];
0150 
0151     <span class="comment">% type changed into list of indicies (use setpentype())</span>
0152     xboxindbar = [];
0153     xboxindphi = [];
0154     <span class="comment">%ineqindbar = [];</span>
0155     ineqindphi = [];
0156     Yboxindbar = [];
0157     Yboxindphi = [];
0158     <span class="comment">%Aindbar = [];</span>
0159     Aindphi = [];
0160 
0161 
0162   <span class="keyword">end</span>
0163 
0164   properties <span class="comment">%(SetAccess = private, GetAccess = private)</span>
0165 
0166     <span class="comment">% time ticker (with every change of xall adds 1)</span>
0167     ticker = 1;
0168     <span class="comment">% (users) x and Y copy (projection) of xall</span>
0169     xYtck = 0;
0170 
0171 
0172     <span class="comment">% all variables, current internal point</span>
0173     xall = [];
0174 
0175     <span class="comment">% Lagrangian multipliers for box inequalities, function ineq. &amp; eq. and new</span>
0176     <span class="comment">% candidates</span>
0177     uxbox = [];
0178     uxboxnew = [];
0179     uineq = [];
0180     uineqnew = [];
0181     ueq = [];
0182     <span class="comment">% Lagrangian multipliers for matrix inequalities: box constr. of matrix</span>
0183     <span class="comment">% variables and matrix constraints inequalities</span>
0184     UYbox = [];
0185     UYboxnew = [];
0186     UA = [];
0187     UAnew = [];
0188 
0189     <span class="comment">% Penalty parameters for all... (except equalities obviously)</span>
0190     pxbox = [];
0191     pineq = [];
0192     PYbox = [];
0193     PA = [];
0194 
0195     <span class="comment">%%% Various values of transformed user data</span>
0196     <span class="comment">% TODO add ticker!!!</span>
0197     objx = 0;
0198     xboxx = [];
0199     ineqx = [];
0200     eqx = [];
0201     <span class="comment">% ticker and Jacobian of equalities</span>
0202     eqdxtck = 0;
0203     eqdx = [];
0204 
0205     <span class="comment">% ticker of the augmented lagrangian and its value at 'xall' point</span>
0206     <span class="comment">% and value of all function equalitites</span>
0207     ALxtck = 0;
0208     ALx = 0;
0209 
0210     <span class="comment">% ticker and the value of the 1st derivative of ALx</span>
0211     ALdxtck = 0;
0212     ALdx = [];
0213 
0214     <span class="comment">% ticker and the value of the Hessian matrix of the Augmented Lagrangian</span>
0215     ALddxtck = 0;
0216     ALddx = [];
0217 
0218     <span class="comment">% stream for log file output</span>
0219     fid = -1;
0220 
0221     <span class="comment">% solve_chol &amp; solvekkt_ldl specific</span>
0222     chol_lmlast = 0;     <span class="comment">% the last nonzero diagonal perturbation</span>
0223     chol_factperm = [];  <span class="comment">% nontrivial permutation used in the last attempt</span>
0224     <span class="comment">% linesearch specific</span>
0225     ls_small_cnt = 0;
0226     ls_rnu = [];
0227   <span class="keyword">end</span>
0228 
0229   properties (Constant)
0230     <span class="comment">% solver name &amp; version</span>
0231     solvername = <span class="string">'PenLab 1.04 (20140125)'</span>;
0232 
0233     <span class="comment">% final solver message based on solverflag</span>
0234     solvermsg = {<span class="string">'converged: optimal solution'</span>, <span class="keyword">...</span>
0235        <span class="string">'converged: suboptimal solution'</span>, <span class="keyword">...</span>
0236        <span class="string">'finished: solution primal infeasible'</span>, <span class="keyword">...</span>
0237        <span class="string">'finished: objective function seems to be unbounded'</span>, <span class="keyword">...</span>
0238        <span class="string">'didn''t converge: unconstrained minimization failed'</span>, <span class="keyword">...</span>
0239        <span class="string">'didn''t converge: no progress, iteration process terminated'</span>, <span class="keyword">...</span>
0240        <span class="string">'didn''t converge: outer iterations reached'</span>, <span class="keyword">...</span>
0241        <span class="string">'didn''t converge: unknown error'</span>, <span class="keyword">...</span>
0242        <span class="string">'hasn''t finished yet'</span>};
0243 
0244     <span class="comment">% default options</span>
0245     <span class="comment">% struct array: name, {default_value, type, restriction}</span>
0246     <span class="comment">% where  name is the name of the option used in allopts or opts</span>
0247     <span class="comment">%        default_value   (==&gt; defopts(1) ~ default allopts structure)</span>
0248     <span class="comment">%        restriction ... depending on the type, restriction to the accepted values</span>
0249     <span class="comment">%        type: 'O' other, no restriction, no checking (e.g. usr_prn)</span>
0250     <span class="comment">%              'S' string, no restriction</span>
0251     <span class="comment">%              'I', 'R' integer or real within range restriction(1)~restriction(2)</span>
0252     <span class="comment">%              'M' multiple choice - one of the elements in array restriction</span>
0253     defopts = struct(<span class="keyword">...</span>
0254       <span class="string">'outlev'</span>, {2, <span class="string">'I'</span>, [0, Inf]}, <span class="keyword">...</span>
0255       <span class="string">'outlev_file'</span>, {5, <span class="string">'I'</span>, [0, Inf]}, <span class="keyword">...</span>
0256       <span class="string">'out_filename'</span>, {<span class="string">'penm_log.txt'</span>, <span class="string">'S'</span>, []}, <span class="keyword">...</span>
0257       <span class="string">'user_prn'</span>, {[], <span class="string">'O'</span>, []}, <span class="keyword">...</span>
0258       <span class="string">'maxotiter'</span>, {100, <span class="string">'I'</span>, [0, Inf]}, <span class="keyword">...</span>
0259       <span class="string">'maxiniter'</span>, {100, <span class="string">'I'</span>, [0, Inf]}, <span class="keyword">...</span>
0260       <span class="keyword">...</span><span class="comment"> % from pennon.m</span>
0261       <span class="string">'penalty_update'</span>, {0.5, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">       % PENALTY_UPDT</span>
0262       <span class="string">'penalty_update_bar'</span>, {0.3, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">   % PENALTY_UPDT_BAR</span>
0263       <span class="string">'mpenalty_update'</span>, {0.5, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">       % </span>
0264       <span class="string">'mpenalty_min'</span>, {1e-6, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">       % </span>
0265       <span class="string">'mpenalty_border'</span>, {1e-6, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">       % </span>
0266       <span class="string">'max_outer_iter'</span>, {100, <span class="string">'I'</span>, [0, Inf]}, <span class="keyword">...</span><span class="comment">       % MAX_PBMITER</span>
0267       <span class="string">'outer_stop_limit'</span>, {1e-6, <span class="string">'R'</span>, [1e-20, 1]}, <span class="keyword">...</span><span class="comment">    % PBMALPHA</span>
0268       <span class="string">'kkt_stop_limit'</span>, {1e-4, <span class="string">'R'</span>, [1e-20, 1]}, <span class="keyword">...</span><span class="comment">      % KKTALPHA</span>
0269       <span class="string">'mlt_update'</span>, {0.3, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">            % MU</span>
0270       <span class="string">'mmlt_update'</span>, {0.1, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">            % MU2</span>
0271       <span class="string">'uinit'</span>, {1, <span class="string">'R'</span>, [-Inf, Inf]}, <span class="keyword">...</span><span class="comment">                  % UINIT</span>
0272       <span class="string">'uinit_box'</span>, {1, <span class="string">'R'</span>, [-Inf, Inf]}, <span class="keyword">...</span><span class="comment">              % UINIT_BOX</span>
0273       <span class="string">'uinit_eq'</span>, {0, <span class="string">'R'</span>, [-Inf, Inf]}, <span class="keyword">...</span><span class="comment">               % UINIT_EQ</span>
0274       <span class="string">'umin'</span>, {1e-10, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">               % UMIN</span>
0275       <span class="string">'pinit'</span>, {1, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">                  % PINIT</span>
0276       <span class="string">'pinit_bar'</span>, {1, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">              % PINIT_BAR</span>
0277       <span class="string">'usebarrier'</span>, {0, <span class="string">'M'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">             % USEBARRIER</span>
0278       <span class="string">'xinit_mod'</span>, {0, <span class="string">'M'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">             % modification of xinit</span>
0279       <span class="keyword">...</span><span class="comment"> % from unconstr_min.m</span>
0280       <span class="string">'max_inner_iter'</span>, {100, <span class="string">'I'</span>, [0, Inf]}, <span class="keyword">...</span><span class="comment">     % MAX_MITER</span>
0281       <span class="string">'inner_stop_limit'</span>, {1e-2, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">    % ALPHA</span>
0282       <span class="string">'unc_dir_stop_limit'</span>, {1e-2, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">  % TOL_DIR</span>
0283       <span class="string">'unc_solver'</span>, {0, <span class="string">'M'</span>, [0, 1, 2, 3, 4, 5]}, <span class="keyword">...</span><span class="comment"> % solver</span>
0284       <span class="string">'unc_linesearch'</span>, {3, <span class="string">'M'</span>, [0, 1, 2, 3]}, <span class="keyword">...</span><span class="comment">   % linesearch</span>
0285       <span class="keyword">...</span><span class="comment"> % from eqconstr_min.m</span>
0286       <span class="string">'eq_dir_stop_limit'</span>, {1e-2, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">   % TOL_DIR</span>
0287       <span class="string">'eq_solver'</span>, {0, <span class="string">'M'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">              % solver</span>
0288       <span class="string">'eq_linesearch'</span>, {3, <span class="string">'M'</span>, [0, 1, 2, 3]}, <span class="keyword">...</span><span class="comment">    % linesearch</span>
0289       <span class="string">'eq_solver_warn_max'</span>, {4, <span class="string">'I'</span>, [0, 10]}, <span class="keyword">...</span><span class="comment">    % solver_warn_max</span>
0290       <span class="string">'ls_short_max'</span>, {3, <span class="string">'I'</span>, [0, 10]}, <span class="keyword">...</span><span class="comment">          % ls_short_max</span>
0291       <span class="string">'min_recover_strategy'</span>, {0, <span class="string">'M'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">   % recover_strategy</span>
0292       <span class="string">'min_recover_max'</span>, {3, <span class="string">'I'</span>, [0, 10]}, <span class="keyword">...</span><span class="comment">       % recover_max</span>
0293       <span class="keyword">...</span><span class="comment"> % from phi2.m</span>
0294       <span class="string">'phi_R'</span>, {-0.5, <span class="string">'R'</span>, [-1, 1]}, <span class="keyword">...</span><span class="comment">              % R_default</span>
0295       <span class="keyword">...</span><span class="comment"> % linesearchs - ls_armijo.m</span>
0296       <span class="string">'max_ls_iter'</span>, {20, <span class="string">'I'</span>, [0, Inf]}, <span class="keyword">...</span><span class="comment">   % max tries before LS fails</span>
0297       <span class="string">'max_lseq_iter'</span>, {20, <span class="string">'I'</span>, [0, Inf]}, <span class="keyword">...</span><span class="comment">   % same for LS for equality constrained problems</span>
0298       <span class="string">'armijo_eps'</span>, {1e-2, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">  % when is armijo step satisfactory? P(alp) - P(0) &lt;= eps*alp*P'(0)</span>
0299       <span class="keyword">...</span><span class="comment"> % solve_simple_chol.m, solkvekkt_ldl.m, solvekkt_lu.m</span>
0300       <span class="string">'ldl_pivot'</span>, {1e-5, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">  % pivot tolerance for delayed pivots in LDL</span>
0301       <span class="string">'pert_update'</span>, {2., <span class="string">'R'</span>, [0, 100]}, <span class="keyword">...</span><span class="comment">  % known aka LMUPDATE, multiplier of the lambda-perturbation factor</span>
0302       <span class="string">'pert_min'</span>, {1e-6, <span class="string">'R'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">   % LMLOW, minimal (starting) perturbation</span>
0303       <span class="string">'pert_try_max'</span>, {50, <span class="string">'I'</span>, [0, Inf]}, <span class="keyword">...</span><span class="comment"> % max number of attempts to successfully perturbate a matrix</span>
0304       <span class="string">'pert_faster'</span>, {1, <span class="string">'M'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment">   % use the last known negative curvature vector to determine perturbation</span>
0305       <span class="keyword">...</span><span class="comment"> % solve_simple_chol.m</span>
0306       <span class="string">'chol_ordering'</span>, {1, <span class="string">'M'</span>, [0, 1]}, <span class="keyword">...</span><span class="comment"> % use symamd for sparse matrices before Cholesky factor.?</span>
0307       <span class="keyword">...</span><span class="comment"> % solvers</span>
0308       <span class="string">'luk3_diag'</span>, {1., <span class="string">'R'</span>, [0, Inf]} <span class="keyword">...</span><span class="comment">  % diagonal of the (2,2)-block in Luksan 3 preconditioner</span>
0309     );
0310 
0311 
0312 
0313   <span class="keyword">end</span>
0314 
0315   methods
0316     Y = <a href="vec2Y.html" class="code" title="function  Y=vec2Y(obj, vec)">vec2Y</a>(obj, vec);
0317     vec = <a href="Y2vec.html" class="code" title="function vec = Y2vec(obj, Y, Ydefault)">Y2vec</a>(obj, Y, Ydefault);
0318     [errmsg] = <a href="print.html" class="code" title="function [errmsg] = print(obj, minlev, maxlev, msg, varargin)">print</a>(obj, minlev, maxlev, msg, varargin);
0319     [errmsg] = <a href="print_opts.html" class="code" title="function [errmsg] = print_opts(obj, minlev, maxlev)">print_opts</a>(obj, minlev, maxlev);
0320     []=<a href="setpentype.html" class="code" title="function []=setpentype(obj,lbxbar,ubxbar,lbYbar,ubYbar)">setpentype</a>(obj,lbxbar,ubxbar,lbYbar,ubYbar);
0321     [] = <a href="init.html" class="code" title="function [] = init(obj, forceupdate)">init</a>(obj, forceupdate);
0322     [ret] = <a href="phi2.html" class="code" title="function [ret] = phi2(obj,t)">phi2</a>(obj,t);
0323     [ret] = <a href="phi2_D.html" class="code" title="function [ret] = phi2_D(obj,t)">phi2_D</a>(obj,t);
0324     [ret] = <a href="phi2_D2.html" class="code" title="function [ret] = phi2_D2(obj,t)">phi2_D2</a>(obj,t);
0325     [ret] = <a href="phibar.html" class="code" title="function [ret] = phibar(obj,t)">phibar</a>(obj,t);
0326     [ret] = <a href="phibar_D.html" class="code" title="function [ret] = phibar_D(obj,t)">phibar_D</a>(obj,t);
0327     [ret] = <a href="phibar_D2.html" class="code" title="function [ret] = phibar_D2(obj,t)">phibar_D2</a>(obj,t);
0328     [status] = <a href="eval_alx.html" class="code" title="function [status] = eval_alx(obj)">eval_alx</a>(obj);
0329     [status] = <a href="eval_aldx.html" class="code" title="function [status] = eval_aldx(obj)">eval_aldx</a>(obj);
0330     [status] = <a href="eval_alddx.html" class="code" title="function [status] = eval_alddx(obj)">eval_alddx</a>(obj);
0331     [] = <a href="clearstats.html" class="code" title="function [] = clearstats(obj)">clearstats</a>(obj);
0332     [dir,nFlag]=<a href="solve_chol.html" class="code" title="function [dir,nFlag]=solve_chol(obj,matrix,rhs)">solve_chol</a>(obj,matrix,rhs);
0333     [x_dir,ueq_dir,nFlag,pert]=<a href="solvekkt_ldl.html" class="code" title="function [x_dir,ueq_dir,nFlag,pert]=solvekkt_ldl(obj,H,A,rhs1,rhs2)">solvekkt_ldl</a>(obj,H,A,rhs1,rhs2);
0334     [rRelStep, nFlag]=<a href="ls_pennon.html" class="code" title="function [rRelStep, nFlag]=ls_pennon(obj, dir)">ls_pennon</a>(obj, dir);
0335     [rRelStep, nFlag]=<a href="lseq_pen.html" class="code" title="function [rRelStep, nFlag]=lseq_pen(obj, dir, udir, miter)">lseq_pen</a>(obj, dir, udir, miter);
0336     [nFlag,rResults]=<a href="unconstr_min.html" class="code" title="function [nFlag,rResults]=unconstr_min(obj)">unconstr_min</a>(obj);
0337     [nFlag,rResults]=<a href="eqconstr_min.html" class="code" title="function [nFlag,rResults]=eqconstr_min(obj)">eqconstr_min</a>(obj);
0338     [] = <a href="logfile.html" class="code" title="function [] = logfile(obj,task)">logfile</a>(obj,task);
0339     <a href="disp.html" class="code" title="function disp(obj)">disp</a>(obj);
0340     [mfeas] = <a href="feas_ay.html" class="code" title="function [mfeas] = feas_ay(obj)">feas_ay</a>(obj);
0341 
0342     <span class="comment">% constructor, you need to provide 'penm' structure</span>
0343     <a name="_sub0" href="#_subfunctions" class="code">function obj = penlab(penm)</a>
0344       <span class="keyword">if</span> (nargin &gt; 0)
0345         <span class="keyword">if</span> (isstruct(penm))
0346 
0347           <span class="comment">% fill in nonexistent (optional) fields</span>
0348           penm=defaultsfiller(penm);
0349 
0350           <span class="comment">% open the filestream if needed</span>
0351           obj.logfile(1);
0352 
0353           <span class="comment">% first options to set up printing</span>
0354           <span class="comment">%obj.opts=penm.opts;</span>
0355 
0356           obj.probname=penm.probname;
0357           obj.comment=penm.comment;
0358 
0359           obj.userdata=penm.userdata;
0360 
0361 
0362           <span class="keyword">if</span> (penm.Nx&lt;0)
0363             error(<span class="string">'ERR: wrong Nx'</span>);
0364           <span class="keyword">else</span>
0365             obj.Nx=penm.Nx;
0366             <span class="comment">% equalities not allowed, unconstrained are OK</span>
0367             [obj.xboxmap, obj.xboxmlt, obj.xboxshift]= <span class="keyword">...</span>
0368                boundschecker(penm.Nx,penm.lbx,penm.ubx,false,true,[]);
0369             obj.Nxbox = length(obj.xboxmap);
0370           <span class="keyword">end</span>
0371 
0372           <span class="keyword">if</span> (penm.NY&lt;0)
0373             error(<span class="string">'ERR: wrong NY'</span>)
0374           <span class="keyword">else</span>
0375             obj.NY=penm.NY;
0376             obj.NYnnz=0;
0377             filterout=[];
0378 
0379             <span class="keyword">for</span> k=1:penm.NY
0380               [mapper, obj.NYnnz]=createY1map(penm.Y{k}, obj.NYnnz);
0381               obj.vec2Ymap{k}=mapper;
0382               <span class="keyword">if</span> (isempty(mapper.xmap))
0383                 <span class="comment">% ignore/exclude from matrix inequality constraints</span>
0384                 filterout = [filterout, k];
0385               <span class="keyword">end</span>
0386             <span class="keyword">end</span>
0387 
0388             <span class="comment">% box equalities on elements of Y (in my notation 'Yx' stuff)</span>
0389             <span class="comment">% what to do with different bounds on the &quot;same&quot; elements</span>
0390             <span class="comment">% (e.g. 5&lt;=x_45 but 3&lt;=x_54) ? --&gt; only lower diag is considered</span>
0391             <span class="comment">% get vectorized lower &amp; upper values (+/-Inf for defaults)</span>
0392             lbYxvec=obj.Y2vec(penm.lbYx,-Inf);
0393             ubYxvec=obj.Y2vec(penm.ubYx,Inf);
0394             <span class="comment">% map inequalities after 'Nx' box inequalitites, equal on elemets</span>
0395             <span class="comment">% is ok but put as 2 inequal, unconstr is allowed</span>
0396             [ineqmap, ineqmlt, ineqshift]= <span class="keyword">...</span>
0397                boundschecker(obj.NYnnz,lbYxvec,ubYxvec,-1,true,[]);
0398             ineqmap=ineqmap+obj.Nx;
0399             obj.xboxmap = [obj.xboxmap, ineqmap];
0400             obj.xboxmlt = [obj.xboxmlt, ineqmlt];
0401             obj.xboxshift = [obj.xboxshift, ineqshift];
0402             obj.Nxbox = obj.Nxbox + length(ineqmap);
0403 
0404             <span class="comment">% equalities not allowed, empty matrices filtered out</span>
0405             [obj.Yboxmap, obj.Yboxmlt, obj.Yboxshift]= <span class="keyword">...</span>
0406                boundschecker(penm.NY,penm.lbY,penm.ubY,false,true,filterout);
0407             obj.NYbox = length(obj.Yboxmap);
0408 
0409             <span class="comment">% how xall (matrix variable) part maps into Y...</span>
0410             obj.Ymap = obj.vec2Y([obj.Nx+1:obj.Nx+obj.NYnnz]);
0411           <span class="keyword">end</span>
0412 
0413           <span class="comment">% any decision variables at all?</span>
0414           <span class="keyword">if</span> (obj.Nx+obj.NYnnz==0)
0415             error(<span class="string">'ERR: no decision variables set!'</span>);
0416           <span class="keyword">end</span>
0417 
0418           <span class="comment">% starting point (unless user offers a better one later)</span>
0419           obj.xall=zeros(obj.Nx+obj.NYnnz,1);
0420           <span class="keyword">if</span> (isfield(penm,<span class="string">'xinit'</span>))
0421             obj.xinit=penm.xinit;
0422           <span class="keyword">end</span>
0423           <span class="keyword">if</span> (isfield(penm,<span class="string">'Yinit'</span>))
0424             obj.Yinit=penm.Yinit;
0425           <span class="keyword">end</span>
0426 
0427           <span class="keyword">if</span> (penm.NgNLN&lt;0 || penm.NgLIN&lt;0)
0428             error(<span class="string">'Ng*&lt;0 error'</span>);
0429           <span class="keyword">else</span>
0430             obj.NgNLN=penm.NgNLN;
0431             obj.NgLIN=penm.NgLIN;
0432 
0433             <span class="comment">% equalities are allowed, unconstrained not</span>
0434             [obj.ineqmap, obj.ineqmlt, obj.ineqshift, obj.eqmap, obj.eqshift]= <span class="keyword">...</span>
0435                boundschecker(penm.NgNLN+penm.NgLIN,penm.lbg,penm.ubg,true,false,[]);
0436             obj.Nineq = length(obj.ineqmap);
0437             obj.Neq = length(obj.eqmap);
0438 
0439           <span class="keyword">end</span>
0440 
0441           <span class="keyword">if</span> (penm.NANLN&lt;0 || penm.NALIN&lt;0)
0442             error(<span class="string">'NA*&lt;0 error'</span>);
0443           <span class="keyword">else</span>
0444             obj.NANLN=penm.NANLN;
0445             obj.NALIN=penm.NALIN;
0446             <span class="comment">% neither equalities inor unconstr are allowed</span>
0447             [obj.Amap, obj.Amlt, obj.Ashift]= <span class="keyword">...</span>
0448                boundschecker(penm.NANLN+penm.NALIN,penm.lbA,penm.ubA,false,false,[]);
0449             obj.NA = length(obj.Amap);
0450 
0451 
0452           <span class="keyword">end</span>
0453 
0454           <span class="comment">% Are callbacks present?</span>
0455           <span class="keyword">if</span> (~isfield(penm,<span class="string">'objfun'</span>) || ~isfield(penm,<span class="string">'objgrad'</span>))
0456             <span class="comment">% could consider it as feasible point problem but at the moment</span>
0457             <span class="comment">% it's an error</span>
0458             error(<span class="string">'objfun and/or objgrad not defined'</span>);
0459           <span class="keyword">end</span>
0460           obj.objfun=penm.objfun;
0461           obj.objgrad=penm.objgrad;
0462           <span class="keyword">if</span> (obj.NgNLN+obj.NgLIN&gt;0)
0463             <span class="keyword">if</span> (~isfield(penm,<span class="string">'confun'</span>) || ~isfield(penm,<span class="string">'congrad'</span>))
0464               error(<span class="string">'confun and/or congrad not defined and constraint are present'</span>);
0465             <span class="keyword">end</span>
0466             obj.confun=penm.confun;
0467             obj.congrad=penm.congrad;
0468           <span class="keyword">end</span>
0469           <span class="keyword">if</span> (isfield(penm,<span class="string">'lagrhess'</span>))
0470             <span class="comment">% hessian of the Lagrangian will be used rather hess of obj &amp; constr</span>
0471             obj.lagrhess=penm.lagrhess;
0472           <span class="keyword">else</span>
0473             <span class="keyword">if</span> (isfield(penm,<span class="string">'objhess'</span>))
0474               obj.objhess=penm.objhess;
0475             <span class="keyword">else</span>
0476               error(<span class="string">'Neither lagrhess nor objhess is defined.'</span>);
0477             <span class="keyword">end</span>
0478             <span class="keyword">if</span> (obj.NgNLN&gt;0 &amp;&amp; ~isfield(penm,<span class="string">'conhess'</span>))
0479               error(<span class="string">'There are nonlinear function constraints and neither lagrhess nor conhess is defined.'</span>);
0480             <span class="keyword">elseif</span> (obj.NgNLN&gt;0)
0481               obj.conhess=penm.conhess;
0482             <span class="keyword">end</span>
0483           <span class="keyword">end</span>
0484           <span class="keyword">if</span> (obj.NALIN+obj.NANLN&gt;0)
0485             <span class="keyword">if</span> (~isfield(penm,<span class="string">'mconfun'</span>) || ~isfield(penm,<span class="string">'mcongrad'</span>))
0486               error(<span class="string">'mconfun and/or mcongrad not defined and matrix constraints present'</span>);
0487             <span class="keyword">end</span>
0488             obj.mconfun=penm.mconfun;
0489             obj.mcongrad=penm.mcongrad;
0490           <span class="keyword">end</span>
0491           <span class="keyword">if</span> (obj.NANLN&gt;0)
0492             <span class="keyword">if</span> (isfield(penm,<span class="string">'mconlagrhess'</span>))
0493               obj.mconlagrhess=penm.mconlagrhess;
0494             <span class="keyword">elseif</span> (isfield(penm,<span class="string">'mconhess'</span>))
0495               obj.mconhess=penm.mconhess;
0496             <span class="keyword">else</span>
0497               error(<span class="string">'Neither mconlagrhess nor mconhess is defined and nonlinear matrix constraints present'</span>);
0498             <span class="keyword">end</span>
0499           <span class="keyword">end</span>
0500 
0501           <span class="comment">% generate Adep - is the current point good for it?</span>
0502            <span class="keyword">if</span> (isfield(penm,<span class="string">'Adep'</span>))
0503                obj.Adep=penm.Adep;
0504            <span class="keyword">else</span>
0505               obj.Adep=cell(obj.NANLN+obj.NALIN,1);
0506               <span class="keyword">for</span> kuser=[1:obj.NANLN+obj.NALIN]
0507                   xh=rand(size(obj.x)); 
0508                   <span class="keyword">if</span> length(obj.Y)&gt;0
0509                   <span class="keyword">for</span> iY=1:length(obj.Y), Yh{iY}=rand(size(obj.Y{iY}));<span class="keyword">end</span>
0510                   <span class="keyword">else</span> Yh{1}=[];<span class="keyword">end</span> 
0511                   [Akx,obj.userdata] = obj.mconfun(xh, Yh, kuser, obj.userdata);
0512                   list=[];
0513                   <span class="keyword">for</span> i=[1:obj.Nx+obj.NYnnz]                   
0514                       [Akdx, obj.userdata] = obj.mcongrad(xh,Yh,kuser,i,obj.userdata);
0515                       <span class="keyword">if</span> (~isempty(Akdx)&amp;&amp; nnz(Akdx)&gt;0)
0516                           list=[list,i];
0517                       <span class="keyword">end</span>
0518                   <span class="keyword">end</span>
0519                   obj.Adep{kuser}=list;
0520               <span class="keyword">end</span>
0521            <span class="keyword">end</span>
0522 
0523           <span class="comment">% generate: *type</span>
0524 
0525 
0526           <span class="comment">% initialize penalty type lists for each constraints (bar/phi?)</span>
0527           obj.setpentype(penm.lbxbar,penm.ubxbar,penm.lbYbar,penm.ubYbar);
0528 
0529         <span class="keyword">else</span>
0530           error(<span class="string">'ERR: provide a penm struct!'</span>);
0531         <span class="keyword">end</span>
0532       <span class="keyword">else</span>
0533         <a href="disp.html" class="code" title="function disp(obj)">disp</a>(<span class="string">'WARNING: Empty object! Call with &quot;penm&quot; structure!'</span>);
0534       <span class="keyword">end</span>
0535       obj.phase = 1;
0536     <span class="keyword">end</span>
0537 
0538     <span class="comment">% destructor</span>
0539     <a name="_sub1" href="#_subfunctions" class="code">function delete(obj)</a>
0540       <span class="comment">% close log file</span>
0541       obj.logfile(0);
0542     <span class="keyword">end</span>
0543 
0544     <span class="comment">% whenever user changes 'opts', check their validity and copy through</span>
0545     <span class="comment">% to allopts; if after INIT phase (=not called from the constructor),</span>
0546     <span class="comment">% report the change to the printer as well (TODO)</span>
0547     <a name="_sub2" href="#_subfunctions" class="code">function set.opts(obj, newopts)</a>
0548       <span class="comment">%disp('changing options?');</span>
0549       <span class="comment">% to accept the option it</span>
0550       <span class="comment">%  - must be already present in 'allopts' (==&gt; must be in penlab.defopts())</span>
0551       <span class="comment">%  - consider only new values</span>
0552       <span class="comment">%  - only if they are allowed (in bounds etc.)</span>
0553 
0554       <span class="comment">%newopts</span>
0555 
0556       <span class="comment">% isstruct?? &amp; nonempty?</span>
0557       <span class="keyword">if</span> (isempty(newopts) || ~isstruct(newopts) || isempty(fieldnames(newopts)))
0558         <span class="comment">% restoring all to defautls</span>
0559         <span class="comment">% if wasn't empty &amp; not init... to avoid the message while init</span>
0560         obj.allopts = penlab.defopts(1);
0561         obj.opts = struct();
0562         obj.logfile(1);
0563         <a href="disp.html" class="code" title="function disp(obj)">disp</a>(<span class="string">'Restoring all option settings to their defaults.'</span>);
0564       <span class="keyword">else</span>
0565 
0566         names=fieldnames(newopts);
0567         discard=find(~isfield(penlab.defopts(1),names));
0568         <span class="keyword">if</span> (~isempty(discard))
0569           str = sprintf(<span class="string">' %s'</span>,names{discard});
0570           fprintf(<span class="string">'Warning: these options don''t exist and are ignored:%s\n'</span>,str);
0571         <span class="keyword">end</span>
0572 
0573         <span class="comment">%keep=find(isfield(obj.allopts,names) &amp;&amp; (~isfield(obj.opts,names) || getfield(obj.opts,names)~=getfield(newopts,names)));</span>
0574         keep=find(isfield(penlab.defopts(1),names));
0575         reopenlog=0;
0576         <span class="keyword">for</span> i=keep'    <span class="comment">% need a row vector</span>
0577           defvalue=getfield(penlab.defopts(1),names{i});
0578           value=getfield(newopts,names{i});
0579           <span class="keyword">if</span> (isfield(obj.opts, names{i}))
0580             origvalue=getfield(obj.opts,names{i});
0581           <span class="keyword">else</span>
0582             origvalue=[];
0583           <span class="keyword">end</span>
0584           oldvalue=getfield(obj.allopts,names{i});
0585           newvalue=oldvalue;
0586 
0587           <span class="comment">% delete, new or change obj.opts.names{i} ??</span>
0588           <span class="keyword">if</span> (isempty(value) &amp;&amp; ~isempty(origvalue))
0589             <span class="comment">% remove this one from user options and restore defaults</span>
0590             obj.opts = rmfield(obj.opts, names{i});
0591             obj.allopts = setfield(obj.allopts, names{i}, defvalue);
0592             newvalue=defvalue;
0593             <a href="disp.html" class="code" title="function disp(obj)">disp</a>(sprintf(<span class="string">'option %s set back to defautls'</span>,names{i}));
0594 
0595           <span class="keyword">elseif</span> (isempty(origvalue) || origvalue~=value)
0596             <span class="comment">% add or change</span>
0597             <span class="comment">% check validity of the new value</span>
0598             obj.opts=setfield(obj.opts, names{i}, value);
0599             obj.allopts=setfield(obj.allopts, names{i}, value);
0600             newvalue=value;
0601             <span class="comment">%disp(sprintf('new option %s set to %g',names{i},value));</span>
0602               <span class="comment">% universal format to print?? value can be anything</span>
0603           <span class="keyword">end</span>
0604 
0605           <span class="comment">% need to reopen the log file?</span>
0606           <span class="keyword">if</span> (strcmp(names{i},<span class="string">'out_filename'</span>) || <span class="keyword">...</span>
0607             strcmp(names{i},<span class="string">'outlev_file'</span>) &amp;&amp; oldvalue*newvalue==0)
0608             reopenlog=1;
0609           <span class="keyword">end</span>
0610         <span class="keyword">end</span>
0611         <span class="keyword">if</span> (reopenlog)
0612           obj.logfile(1);
0613         <span class="keyword">end</span>
0614       <span class="keyword">end</span>
0615     <span class="keyword">end</span>
0616 
0617     <span class="comment">% Keep an eye on changes of xall (internal variables) and update ticker</span>
0618     <span class="comment">% to set the rest as invalid; this is the only place where ticker should</span>
0619     <span class="comment">% be updated</span>
0620     <a name="_sub3" href="#_subfunctions" class="code">function set.xall(obj, xall)</a>
0621       <span class="comment">%disp('...Tick, xall updated');</span>
0622       <span class="comment">% TODO if ticker is maxint, reset all tickers</span>
0623       obj.ticker=obj.ticker+1;
0624       obj.xall=xall;
0625     <span class="keyword">end</span>
0626 
0627     <span class="comment">% Update x &amp; Y from xall if not already up-to-date</span>
0628     <a name="_sub4" href="#_subfunctions" class="code">function x=get.x(obj)</a>
0629       <span class="keyword">if</span> (obj.xYtck&lt;obj.ticker)
0630         <span class="comment">%disp('...update of x,Y initialized by x');</span>
0631         obj.x=obj.xall(1:obj.Nx);
0632         obj.Y=obj.vec2Y(obj.xall(obj.Nx+1:end));
0633         obj.xYtck=obj.ticker;
0634       <span class="keyword">end</span>
0635       x=obj.x;
0636     <span class="keyword">end</span>
0637 
0638     <span class="comment">% Update x &amp; Y from xall if not already up-to-date</span>
0639     <a name="_sub5" href="#_subfunctions" class="code">function Y=get.Y(obj)</a>
0640       <span class="keyword">if</span> (obj.xYtck&lt;obj.ticker)
0641         <span class="comment">%disp('...update of x,Y initialized by Y');</span>
0642         obj.x=obj.xall(1:obj.Nx);
0643         obj.Y=obj.vec2Y(obj.xall(obj.Nx+1:end));
0644         obj.xYtck=obj.ticker;
0645       <span class="keyword">end</span>
0646       Y=obj.Y;
0647     <span class="keyword">end</span>
0648 
0649     <span class="comment">% changing starting x by user is not allowed during solving</span>
0650     <a name="_sub6" href="#_subfunctions" class="code">function set.xinit(obj,x)</a>
0651       <span class="keyword">if</span> (obj.phase==2)
0652         error(<span class="string">'Changing x during computation is not allowed.'</span>);
0653       <span class="keyword">end</span>
0654 
0655       <span class="comment">%%%disp('...changing x starting point');</span>
0656       <span class="keyword">if</span> (length(x)~=obj.Nx)
0657         error(<span class="string">'wrong dimension of x'</span>);
0658       <span class="keyword">end</span>
0659       obj.xall(1:obj.Nx) = x;
0660       <span class="keyword">if</span> (obj.phase==3)
0661         <span class="comment">% throw away all results, TODO prehaps need to do something more?</span>
0662         obj.phase=1;
0663       <span class="keyword">end</span>
0664     <span class="keyword">end</span>
0665 
0666     <span class="comment">% changing starting Y (not allowed during solving)</span>
0667     <a name="_sub7" href="#_subfunctions" class="code">function set.Yinit(obj,Y)</a>
0668       <span class="keyword">if</span> (obj.phase==2)
0669         error(<span class="string">'Changing Y during computation is not allowed.'</span>);
0670       <span class="keyword">end</span>
0671 
0672       <span class="comment">%%%disp('...changing Y starting point');</span>
0673       <span class="comment">% if Y is not complete, use current xall to fill in gaps</span>
0674       obj.xall(obj.Nx+1:end)=obj.Y2vec(Y);
0675       <span class="keyword">if</span> (obj.phase==3)
0676         <span class="comment">% throw away all results, TODO prehaps need to do something more?</span>
0677         obj.phase=1;
0678       <span class="keyword">end</span>
0679     <span class="keyword">end</span>
0680 
0681 
0682   <span class="keyword">end</span>
0683 
0684   methods (Static)
0685 
0686     <span class="comment">% default Problem name</span>
0687     <a name="_sub8" href="#_subfunctions" class="code">function dname = default_probname()</a>
0688       dname = [<span class="string">'Pennon NLP-SDP problem '</span>, datestr(now) ];
0689     <span class="keyword">end</span>
0690 
0691     <span class="comment">% default option settings (only values can be changed, new options</span>
0692     <span class="comment">% need to have a default value first)</span>
0693     <a name="_sub9" href="#_subfunctions" class="code">function dopts = default_opts()</a>
0694       dopts = [];
0695       dopts.outlev = 2;
0696       dopts.outlev_file = 5;
0697       dopts.out_filename = <span class="string">'penm_log.txt'</span>;
0698       dopts.user_prn = [];
0699       dopts.maxotiter = 100;
0700       dopts.maxiniter = 100;
0701       <span class="comment">% ...</span>
0702       <span class="comment">% from pennon.m</span>
0703       dopts.penalty_update = 0.5;       <span class="comment">% PENALTY_UPDT</span>
0704       dopts.penalty_update_bar = 0.3;   <span class="comment">% PENALTY_UPDT_BAR</span>
0705       dopts.max_outer_iter = 100;       <span class="comment">% MAX_PBMITER</span>
0706       dopts.outer_stop_limit = 1e-6;    <span class="comment">% PBMALPHA</span>
0707       dopts.kkt_stop_limit = 1e-4;      <span class="comment">% KKTALPHA</span>
0708       dopts.mlt_update =0.3;            <span class="comment">% MU</span>
0709       dopts.uinit = 1;                  <span class="comment">% UINIT</span>
0710       dopts.uinit_box = 1;              <span class="comment">% UINIT_BOX</span>
0711       dopts.uinit_eq = 0;               <span class="comment">% UINIT_EQ</span>
0712       dopts.umin = 1e-10;               <span class="comment">% UMIN</span>
0713       dopts.pinit = 1;                  <span class="comment">% PINIT</span>
0714       dopts.pinit_bar = 1;              <span class="comment">% PINIT_BAR</span>
0715       dopts.usebarrier = 0;             <span class="comment">% USEBARRIER</span>
0716       <span class="comment">% from unconstr_min.m</span>
0717       dopts.max_inner_iter = 100;       <span class="comment">% MAX_MITER</span>
0718       dopts.inner_stop_limit = 1e-2;    <span class="comment">% ALPHA</span>
0719       dopts.unc_dir_stop_limit = 1e-2;  <span class="comment">% TOL_DIR</span>
0720       dopts.unc_solver = 0;             <span class="comment">% solver</span>
0721       dopts.unc_linesearch = 3;         <span class="comment">% linesearch</span>
0722       <span class="comment">% from eqconstr_min.m</span>
0723       dopts.eq_dir_stop_limit = 1e-2;   <span class="comment">% TOL_DIR</span>
0724       dopts.eq_solver = 0;              <span class="comment">% solver</span>
0725       dopts.eq_linesearch = 3;          <span class="comment">% linesearch</span>
0726       dopts.eq_solver_warn_max = 4;     <span class="comment">% solver_warn_max</span>
0727       dopts.ls_short_max = 3;           <span class="comment">% ls_short_max</span>
0728       dopts.min_recover_strategy = 0;   <span class="comment">% recover_strategy</span>
0729       dopts.min_recover_max = 3;        <span class="comment">% recover_max</span>
0730       <span class="comment">% from phi2.m</span>
0731       dopts.phi_R = -0.5;               <span class="comment">% R_default</span>
0732 
0733       <span class="comment">% linesearchs - ls_armijo.m</span>
0734       dopts.max_ls_iter = 20;   <span class="comment">% max tries before LS fails</span>
0735       dopts.max_lseq_iter = 20;   <span class="comment">% same for LS for equality constrained problems</span>
0736       dopts.armijo_eps = 1e-2;  <span class="comment">% when is armijo step satisfactory? P(alp) - P(0) &lt;= eps*alp*P'(0)</span>
0737 
0738       <span class="comment">% solve_simple_chol.m, solkvekkt_ldl.m, solvekkt_lu.m</span>
0739       dopts.pert_update = 2.;  <span class="comment">% known aka LMUPDATE, multiplier of the lambda-perturbation factor</span>
0740       dopts.pert_min = 1e-6;   <span class="comment">% LMLOW, minimal (starting) perturbation</span>
0741       dopts.pert_try_max = 50; <span class="comment">% max number of attempts to successfully perturbate a matrix</span>
0742       dopts.pert_faster = 1;   <span class="comment">% use the last known negative curvature vector to determine perturbation</span>
0743 
0744       <span class="comment">% solve_simple_chol.m</span>
0745       dopts.chol_ordering = 1; <span class="comment">% use symamd for sparse matrices before Cholesky factor.?</span>
0746 
0747       <span class="comment">% solvers</span>
0748       dopts.luk3_diag = 1;  <span class="comment">% diagonal of the (2,2)-block in Luksan 3 preconditioner</span>
0749       <span class="comment">%%% different stuff from previous 'popt' structure %%%</span>
0750       <span class="comment">% equality constrained/unconstrained minimization</span>
0751       <span class="comment">% - eqconstr_min.m, unconstr_min.m</span>
0752       <span class="comment">%dopts.eq_dir_max_prec = 1e-6; % upper limit to the precision of a solution, do not demand a better (absolute) precision than this one; set 0 to turn it off</span>
0753 
0754       <span class="comment">% tracing of one inner loop</span>
0755       <span class="comment">%dopts.trace = 0;   % turn on tracing?</span>
0756       <span class="comment">%dopts.trace_outer_iter = 1; % which outer iteration to trace? (1~the whole first iter ~ from the very beginning)</span>
0757       <span class="comment">%dopts.trace_filename='trace_point.dcf'; % name of the dcf file if used</span>
0758 
0759     <span class="keyword">end</span>
0760 
0761   <span class="keyword">end</span>
0762 
0763 
0764 <span class="keyword">end</span>
0765</pre></div>
<hr><address>Generated on Mon 26-Aug-2019 10:22:08 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>